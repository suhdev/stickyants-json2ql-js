import { ISqlRefiner } from './ISqlRefiner';
import { SqlOperator, SqlRefinerType, SqlQueryFlags, SqlModifier } from './enums';
import { ISqlRefinable } from './ISqlRefinable';
import { SqlCondition } from './SqlCondition';
import { SqlSort } from './SqlSort';
import { SqlJoin } from './SqlJoin';
export declare class SqlQueryModel {
    private $table;
    private $as;
    private $skip;
    private $count;
    private $isStats;
    private $modifiers;
    private $isDistinct;
    private $operator;
    private $refiners;
    private $having;
    private $joins;
    private $groupBy;
    private $sorters;
    private $selection;
    private $tableIdentifier;
    private $parent;
    private $key;
    private $with;
    private $type;
    constructor(op?: SqlOperator, parentModel?: SqlQueryModel, key?: string);
    readonly asRelation: this;
    readonly asGrouping: this;
    filter(...args: ISqlRefinable[]): this;
    filterHaving(...args: ISqlRefinable[]): this;
    groupBy(...args: string[]): this;
    order(...args: ISqlRefinable[]): this;
    addSort(sort: ISqlRefiner): void;
    addSorters(sorters: ISqlRefiner[]): void;
    table(table: string): this;
    as(as: string): this;
    selection(sel: string[]): this;
    orderBy(key: string): SqlSort;
    and(): this;
    or(): this;
    key(key: string): this;
    modifier(mod: SqlModifier): this;
    isBetween(key: string, from: any, to: any, flags?: SqlQueryFlags): this;
    isNotBetween(key: string, from: any, to: any, flags?: SqlQueryFlags): this;
    with(...args: SqlQueryModel[]): this;
    join(cb: (model: SqlJoin) => void): this;
    joinWith(joinTable: string, cb: (model: SqlJoin) => void): this;
    operator(op: SqlOperator): this;
    readonly distinct: this;
    skip(skip: number): this;
    ref(key: string): SqlCondition;
    addRefiner(...refs: ISqlRefiner[]): this;
    readonly stats: this;
    count(count: number): this;
    tableIdentifier(id: string): this;
    group(op: SqlOperator): SqlQueryModel;
    andGroup(): SqlQueryModel;
    orGroup(): SqlQueryModel;
    refiner(key: string, value: any, operator: SqlOperator, type: SqlRefinerType, flags?: SqlQueryFlags): this;
    addRefiners(refiners: ISqlRefiner[]): this;
    text(key: string, value: any, operator: SqlOperator, flags?: SqlQueryFlags): this;
    number(key: string, value: any, operator: SqlOperator, flags?: SqlQueryFlags): this;
    bool(key: string, value: any, operator: SqlOperator, flags?: SqlQueryFlags): this;
    isIn(key: string, value: any, flags?: SqlQueryFlags): this;
    isNotIn(key: string, value: any, flags?: SqlQueryFlags): this;
    readonly relation: SqlQueryModel;
    relationOn(key: string): SqlQueryModel;
    end(): SqlQueryModel | {
        with: SqlQueryModel[];
        joins: SqlJoin[];
        having: ISqlRefiner[];
        groupBy: string[];
        refiners: ISqlRefiner[];
        sorters: ISqlRefiner[];
        table: string;
        as: string;
        tableIdentifier: string;
        count: number;
        skip: number;
        modifiers: SqlModifier;
        refinersOperator: SqlOperator;
        selection: string[];
        isStats: boolean;
    };
    toSqlRefiner(): {
        key: string;
        type: SqlRefinerType;
        refiners: ISqlRefiner[];
        value: any;
        operator: SqlOperator;
        relation?: undefined;
    } | {
        key: string;
        type: SqlRefinerType;
        value: any;
        operator: SqlOperator;
        relation: {
            joins: SqlJoin[];
            having: ISqlRefiner[];
            groupBy: string[];
            refiners: ISqlRefiner[];
            sorters: ISqlRefiner[];
            table: string;
            as: string;
            tableIdentifier: string;
            count: number;
            skip: number;
            isDistinct: boolean;
            refinersOperator: SqlOperator;
            selection: string[];
            isStats: boolean;
        };
        refiners?: undefined;
    };
    toJSON(): {
        with: SqlQueryModel[];
        joins: SqlJoin[];
        having: ISqlRefiner[];
        groupBy: string[];
        refiners: ISqlRefiner[];
        sorters: ISqlRefiner[];
        table: string;
        as: string;
        tableIdentifier: string;
        count: number;
        skip: number;
        modifiers: SqlModifier;
        refinersOperator: SqlOperator;
        selection: string[];
        isStats: boolean;
    };
    build(): {
        with: SqlQueryModel[];
        joins: SqlJoin[];
        having: ISqlRefiner[];
        groupBy: string[];
        refiners: ISqlRefiner[];
        sorters: ISqlRefiner[];
        table: string;
        as: string;
        tableIdentifier: string;
        count: number;
        skip: number;
        modifiers: SqlModifier;
        refinersOperator: SqlOperator;
        selection: string[];
        isStats: boolean;
    };
}
